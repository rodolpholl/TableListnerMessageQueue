-- ###############################################################
-- # SCRIPT DE CONFIGURAÇÃO ORACLE PARA INTEGRAÇÃO COM RABBITMQ #
-- ###############################################################

-- Este script contém a criação de sequences, tabelas, configuração do
-- Oracle Advanced Queuing (AQ), um procedimento PLSQL e um trigger
-- para automatizar o envio de mensagens para o AQ quando um novo
-- autor é inserido.

-- Conecte-se com um usuário que tenha privilégios para criar objetos
-- de banco de dados (ex: DBA, SYSTEM, ou um usuário com as permissões
-- necessárias).

--------------------------------------------------------------------
-- 1. Criação das Sequences
--------------------------------------------------------------------

-- Sequence para a tabela AUTOR, para preenchimento automático do Id
CREATE SEQUENCE C##_TESTEMSG.AUTOR_ID_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;


-- Sequence para a tabela LIVRO, para preenchimento automático do Id
CREATE SEQUENCE C##_TESTEMSG.LIVRO_ID_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;


--------------------------------------------------------------------
-- 2. Criação das Tabelas AUTOR e LIVRO
--------------------------------------------------------------------

-- Tabela AUTOR
CREATE TABLE C##_TESTEMSG.AUTOR (
    Id            NUMBER(19) DEFAULT AUTOR_ID_SEQ.NEXTVAL PRIMARY KEY,
    Nome          VARCHAR2(150) NOT NULL,
    DataNascimento DATE,
    Email         VARCHAR2(150) UNIQUE,
    Phone         VARCHAR2(30)
);


-- Tabela LIVRO
CREATE TABLE C##_TESTEMSG.LIVRO (
    Id            NUMBER(19) DEFAULT LIVRO_ID_SEQ.NEXTVAL PRIMARY KEY,
    Autor_Id      NUMBER(19) NOT NULL,
    Titulo        VARCHAR2(300) NOT NULL,
    Num_Paginas   NUMBER(5),
    Categoria     VARCHAR2(150),
    CONSTRAINT FK_LIVRO_AUTOR FOREIGN KEY (Autor_Id) REFERENCES C##_TESTEMSG.AUTOR(Id)
);

CREATE TABLE "C##_TESTEMSG".CLIENTE (
	ID NUMBER(19,0) DEFAULT C##_TESTEMSG.CLIENTE_ID_SEQ.NEXTVAL ,
	NOME VARCHAR2(150),
	EMAIL VARCHAR2(300),
	PHONE VARCHAR2(50),
	DATA_NASC DATE,
	AUTOR_FAVORITO_ID NUMBER(19,0),
	CONSTRAINT CLIENTE_PK PRIMARY KEY (ID),
	CONSTRAINT SYS_C008608 CHECK ("ID" IS NOT NULL),
	CONSTRAINT SYS_C008609 CHECK ("NOME" IS NOT NULL),
	CONSTRAINT SYS_C008610 CHECK ("EMAIL" IS NOT NULL)
);
CREATE UNIQUE INDEX CLIENTE_PK ON "C##_TESTEMSG".CLIENTE (ID);


-- "C##_TESTEMSG".CLIENTE chaves estrangeiras

ALTER TABLE "C##_TESTEMSG"."CLIENTE" ADD CONSTRAINT "CLIENTE_AUTOR_FK" FOREIGN KEY ("AUTOR_FAVORITO_ID")
	  REFERENCES "C##_TESTEMSG"."AUTOR" ("ID") ENABLE;


-- "C##_TESTEMSG".FAVORITOS definição

-- DDL generated by DBeaver
-- WARNING: It may differ from actual native database DDL

-- Drop table

-- DROP TABLE "C##_TESTEMSG".FAVORITOS;

CREATE TABLE "C##_TESTEMSG".FAVORITOS (
	ID NUMBER(19,0) DEFAULT "C##_TESTEMSG".FAVORITOS_ID_SEQ.NEXTVAL ,
	CLIENTE_ID NUMBER(19,0),
	LIVRO_ID NUMBER(19,0),
	CONSTRAINT FAVORITOS_PK PRIMARY KEY (ID),
	CONSTRAINT SYS_C008613 CHECK ("ID" IS NOT NULL),
	CONSTRAINT SYS_C008614 CHECK ("CLIENTE_ID" IS NOT NULL),
	CONSTRAINT SYS_C008615 CHECK ("LIVRO_ID" IS NOT NULL)
);
CREATE UNIQUE INDEX FAVORITOS_CLIENTE_ID_IDX ON "C##_TESTEMSG".FAVORITOS (CLIENTE_ID,LIVRO_ID);
CREATE UNIQUE INDEX FAVORITOS_PK ON "C##_TESTEMSG".FAVORITOS (ID);


-- "C##_TESTEMSG".FAVORITOS chaves estrangeiras

ALTER TABLE "C##_TESTEMSG"."FAVORITOS" ADD CONSTRAINT "FAVORITOS_CLIENTE_FK" FOREIGN KEY ("CLIENTE_ID")
	  REFERENCES "C##_TESTEMSG"."CLIENTE" ("ID") ENABLE;
  ALTER TABLE "C##_TESTEMSG"."FAVORITOS" ADD CONSTRAINT "FAVORITOS_LIVRO_FK" FOREIGN KEY ("LIVRO_ID")
	  REFERENCES "C##_TESTEMSG"."LIVRO" ("ID") ENABLE;


-- Opcional: Adicionar comentários para documentar as tabelas
COMMENT ON TABLE C##_TESTEMSG.AUTOR IS 'Armazena informações sobre os autores de livros.';
COMMENT ON COLUMN C##_TESTEMSG.AUTOR.Id IS 'Identificador único do autor.';
COMMENT ON COLUMN C##_TESTEMSG.AUTOR.Nome IS 'Nome completo do autor.';
COMMENT ON COLUMN C##_TESTEMSG.AUTOR.DataNascimento IS 'Data de nascimento do autor.';
COMMENT ON COLUMN C##_TESTEMSG.AUTOR.Email IS 'Endereço de e-mail do autor (deve ser único).';
COMMENT ON COLUMN C##_TESTEMSG.AUTOR.Phone IS 'Número de telefone do autor.';

COMMENT ON TABLE C##_TESTEMSG.LIVRO IS 'Armazena informações sobre os livros.';
COMMENT ON COLUMN C##_TESTEMSG.LIVRO.Id IS 'Identificador único do livro.';
COMMENT ON COLUMN C##_TESTEMSG.LIVRO.Autor_Id IS 'Chave estrangeira para a tabela AUTOR, indicando o autor do livro.';
COMMENT ON COLUMN C##_TESTEMSG.LIVRO.Titulo IS 'Título do livro.';
COMMENT ON COLUMN C##_TESTEMSG.LIVRO.Num_Paginas IS 'Número de páginas do livro.';
COMMENT ON COLUMN C##_TESTEMSG.LIVRO.Categoria IS 'Categoria ou gênero do livro.';

--------------------------------------------------------------------
-- 3. Configuração do Oracle Advanced Queuing (AQ)
--------------------------------------------------------------------

-- 3.1. Parar e remover fila existente se necessário
DECLARE
    v_queue_exists NUMBER;
BEGIN
    -- Verifica se a fila existe
    SELECT COUNT(*)
    INTO v_queue_exists
    FROM ALL_QUEUES
    WHERE NAME = 'AUTOR_NOVOS_JSON_QUEUE'
    AND OWNER = 'C##_TESTEMSG';

    IF v_queue_exists > 0 THEN
        -- Tenta parar a fila apenas se ela existir
        BEGIN
            DBMS_AQADM.STOP_QUEUE(
                queue_name => 'C##_TESTEMSG.AUTOR_NOVOS_JSON_QUEUE'
            );
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -24010 THEN -- Ignora erro se a fila não existe
                    RAISE;
                END IF;
        END;

        -- Tenta dropar a fila
        BEGIN
            DBMS_AQADM.DROP_QUEUE(
                queue_name => 'C##_TESTEMSG.AUTOR_NOVOS_JSON_QUEUE'
            );
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -24010 THEN -- Ignora erro se a fila não existe
                    RAISE;
                END IF;
        END;
    END IF;

    -- Verifica se a tabela da fila existe
    SELECT COUNT(*)
    INTO v_queue_exists
    FROM ALL_QUEUE_TABLES
    WHERE QUEUE_TABLE = 'AUTOR_JSON_QTABLE'
    AND OWNER = 'C##_TESTEMSG';

    IF v_queue_exists > 0 THEN
        -- Tenta dropar a tabela da fila
        BEGIN
            DBMS_AQADM.DROP_QUEUE_TABLE(
                queue_table => 'C##_TESTEMSG.AUTOR_JSON_QTABLE'
            );
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -24002 THEN -- Ignora erro se a tabela não existe
                    RAISE;
                END IF;
        END;
    END IF;
END;


-- 4. Criar nova infraestrutura AQ
/*BEGIN
    DBMS_AQADM.CREATE_QUEUE_TABLE (
        queue_table          => 'C##_TESTEMSG.AUTOR_JSON_QTABLE',
        queue_payload_type   => 'SYS.AQ$_JMS_TEXT_MESSAGE',
        multiple_consumers   => FALSE
    );
END;


BEGIN
    DBMS_AQADM.CREATE_QUEUE (
        queue_name           => 'C##_TESTEMSG.AUTOR_NOVOS_JSON_QUEUE',
        queue_table          => 'C##_TESTEMSG.AUTOR_JSON_QTABLE'
    );
END;


BEGIN
    DBMS_AQADM.START_QUEUE (
        queue_name           => 'C##_TESTEMSG.AUTOR_NOVOS_JSON_QUEUE'
    );
END;*/


BEGIN
    DBMS_AQADM.CREATE_QUEUE_TABLE (
        queue_table          => 'C##_TESTEMSG.QUEUE_JSON_QTABLE',
        queue_payload_type   => 'SYS.AQ$_JMS_TEXT_MESSAGE',
        multiple_consumers   => FALSE
    );
END;

BEGIN
    DBMS_AQADM.CREATE_QUEUE (
        queue_name           => 'C##_TESTEMSG.QUEUE_NOVOS_JSON_QUEUE',
        queue_table          => 'C##_TESTEMSG.QUEUE_JSON_QTABLE'
    );
END;

BEGIN
    DBMS_AQADM.START_QUEUE (
        queue_name           => 'C##_TESTEMSG.QUEUE_NOVOS_JSON_QUEUE'
    );
END;





-- 3.4. Conceda permissões necessárias ao usuário do banco de dados
-- Substitua 'SEU_USUARIO_DB' pelo usuário real que fará INSERTs e DEQUEUEs.
-- Este usuário precisará destas permissões para interagir com o AQ.
GRANT EXECUTE ON DBMS_AQADM TO C##_TESTEMSG;
GRANT EXECUTE ON DBMS_AQ TO C##_TESTEMSG;
GRANT EXECUTE ON SYS.AQ$_JMS_TEXT_MESSAGE TO C##_TESTEMSG;
GRANT CREATE SESSION TO C##_TESTEMSG;
GRANT CREATE TABLE TO C##_TESTEMSG;
GRANT CREATE SEQUENCE TO C##_TESTEMSG;
GRANT CREATE PROCEDURE TO C##_TESTEMSG;
GRANT CREATE TRIGGER TO C##_TESTEMSG;
ALTER USER C##_TESTEMSG QUOTA UNLIMITED ON USERS;


--------------------------------------------------------------------
-- 4. Procedimento PLSQL para Enfileirar Mensagens no AQ
--------------------------------------------------------------------

-- CORREÇÃO: Ajustado para usar o tipo SYS.AQ$_JMS_TEXT_MESSAGE
CREATE OR REPLACE PROCEDURE C##_TESTEMSG.ENQUEUE_NOVO_AUTOR_JSON (
    p_autor_id      IN NUMBER,
    p_autor_nome    IN VARCHAR2,
    p_autor_email   IN VARCHAR2
) AS
    enqueue_options    DBMS_AQ.ENQUEUE_OPTIONS_T;
    message_properties DBMS_AQ.MESSAGE_PROPERTIES_T;
    message_handle     RAW(16);
    json_string        VARCHAR2(4000); -- A string JSON que você quer enviar
    aq_message_obj     SYS.AQ$_JMS_TEXT_MESSAGE; -- Objeto do tipo de payload
BEGIN
    -- Monta a string JSON com os dados relevantes do novo autor
    -- Usando REPLACE para escapar aspas duplas, caso o nome ou email contenham
    json_string := '{"Id":' || p_autor_id || ',"Nome":"' || REPLACE(p_autor_nome, '"', '\"') || '","Email":"' || REPLACE(p_autor_email, '"', '\"') || '"}';

    -- Cria um novo objeto JMS_TEXT_MESSAGE
    aq_message_obj := SYS.AQ$_JMS_TEXT_MESSAGE.construct();
    aq_message_obj.set_text(json_string); -- Define o texto da mensagem

    DBMS_AQ.ENQUEUE(
        queue_name         => 'C##_TESTEMSG.AUTOR_NOVOS_JSON_QUEUE',
        enqueue_options    => enqueue_options,
        message_properties => message_properties,
        payload            => aq_message_obj, -- <-- AGORA PASSAMOS O OBJETO JMS
        msgid              => message_handle
    );
    -- IMPORTANTE: O COMMIT aqui não é necessário e deve ser evitado.
    -- O COMMIT será realizado pela transação que inseriu o registro na tabela AUTOR.
END;



CREATE OR REPLACE PROCEDURE C##_TESTEMSG.ENQUEUE_NOVO_JSON (
    p_json_string      IN VARCHAR2    
) AS
    enqueue_options    DBMS_AQ.ENQUEUE_OPTIONS_T;
    message_properties DBMS_AQ.MESSAGE_PROPERTIES_T;
    message_handle     RAW(16);
    json_string        VARCHAR2(32767); -- A string JSON que você quer enviar
    aq_message_obj     SYS.AQ$_JMS_TEXT_MESSAGE; -- Objeto do tipo de payload
BEGIN
       -- Cria um novo objeto JMS_TEXT_MESSAGE
    aq_message_obj := SYS.AQ$_JMS_TEXT_MESSAGE.construct();
    aq_message_obj.set_text(p_json_string); -- Define o texto da mensagem

    DBMS_AQ.ENQUEUE(
        queue_name         => 'C##_TESTEMSG.QUEUE_NOVOS_JSON_QUEUE',
        enqueue_options    => enqueue_options,
        message_properties => message_properties,
        payload            => aq_message_obj, -- <-- AGORA PASSAMOS O OBJETO JMS
        msgid              => message_handle
    );
    -- IMPORTANTE: O COMMIT aqui não é necessário e deve ser evitado.
    -- O COMMIT será realizado pela transação que inseriu o registro na tabela AUTOR.
END;


--------------------------------------------------------------------
-- 5. Trigger AFTER INSERT na Tabela AUTOR
--------------------------------------------------------------------

-- Este trigger será disparado automaticamente após a inserção de
-- um novo registro na tabela AUTOR.
CREATE OR REPLACE TRIGGER C##_TESTEMSG.TRG_AUTOR_AFTER_INSERT
AFTER INSERT ON C##_TESTEMSG.AUTOR
FOR EACH ROW
BEGIN
    -- Chama o procedimento para enfileirar os dados do novo autor
    -- na fila do Oracle AQ para processamento externo.
    C##_TESTEMSG.ENQUEUE_NOVO_AUTOR_JSON(
        p_autor_id    => :NEW.Id,      -- Id do autor recém-inserido
        p_autor_nome  => :NEW.Nome,    -- Nome do autor recém-inserido
        p_autor_email => :NEW.Email    -- E-mail do autor recém-inserido
    );
END;



--------------------------------------------------------------------
-- 6. Trigger AFTER INSERT na Tabela CLIENTE
--------------------------------------------------------------------

-- Este trigger será disparado automaticamente após a inserção de
-- um novo registro na tabela AUTOR.
CREATE OR REPLACE TRIGGER C##_TESTEMSG.TRG_CLIENTE_AFTER_INSERT
AFTER INSERT ON C##_TESTEMSG.CLIENTE
FOR EACH ROW
DECLARE
    autor_favorito NUMBER;
    json_string VARCHAR2(32767);
BEGIN
    autor_favorito := :NEW.AUTOR_FAVORITO_ID;
    
    IF autor_favorito IS NOT NULL THEN
        -- JSON string corrigido com aspas duplas adequadas
        -- 2 é o código enum do Cliente.
        json_string := '{"table":2, "data":{"clienteId":' || :NEW.Id || ', "autorFavoritoId":' || autor_favorito || '}}';
        
        -- Chamada da procedure
        C##_TESTEMSG.ENQUEUE_NOVO_JSON(p_json_string => json_string);
    END IF;
END;


-- Verificar se as tabelas foram criadas
SELECT table_name FROM user_tables;

-- Verificar se as sequences foram criadas
SELECT sequence_name FROM user_sequences;

-- Verificar se a fila AQ está ativa
SELECT name, queue_type, enabled FROM user_queues;

-- Verificar se o procedimento foi criado
SELECT object_name, object_type FROM user_objects WHERE object_type = 'PROCEDURE';

-- Verificar se o trigger foi criado
SELECT trigger_name, status FROM user_triggers;

-- Verificar se a mensagem está na fila
SELECT q.msg_id, q.user_data.text_vc
FROM C##_TESTEMSG.AUTOR_JSON_QTABLE q;

DECLARE
    enqueue_options    DBMS_AQ.ENQUEUE_OPTIONS_T;
    message_properties DBMS_AQ.MESSAGE_PROPERTIES_T;
    message_handle    RAW(16);
    message           autor_message_type;
BEGIN
    message := autor_message_type('{"id": 1, "nome": "Autor Teste"}');
    
    DBMS_AQ.ENQUEUE(
        queue_name => 'AUTOR_NOVOS_JSON_QUEUE',
        enqueue_options => enqueue_options,
        message_properties => message_properties,
        payload => message,
        msgid => message_handle
    );
    COMMIT;
END;


-- Teste de inserção
INSERT INTO C##_TESTEMSG.AUTOR (Nome, Email) 
VALUES ('Autor Teste', 'autor@teste.com');
COMMIT;

-- Fim do script de configuração Oracle.
-- Após a execução, verifique a criação de todos os objetos.